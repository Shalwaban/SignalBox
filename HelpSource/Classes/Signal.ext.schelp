CLASSMETHODS::


METHOD:: rfftCosTable

Fourier Transform: Fill a Signal with the cosine table needed by the Real-FFT methods. See also the instance methods link::#-rfft:: and link::#-irfft::.

code::
Signal.rfftCosTable(512/2 + 1).plot;
::

METHOD:: rfftTwoCosTable

Fourier Transform: Fill a Signal with the cosine table needed by the Real-FFT-Two methods. See also the instance methods link::#-rfftTwo:: and link::#-irfftTwo::.

code::
Signal.rfftTwoCosTable(512/2 + 1).plot;
::

METHOD:: cosineFill

Fill a Signal of the given size with a sum of cosines at the given amplitudes and phases. The Signal will be normalized.

code::
Signal.cosineFill(1000, 1.0/[1, 2, 3, 4, 5, 6]).plot;
::

argument:: size
the number of samples in the Signal.

argument:: amplitudes
an Array of amplitudes for each harmonic beginning with the fundamental.

argument:: phases
an Array of phases in radians for each harmonic beginning with the fundamental.


METHOD:: zeroFill

Fill a Signal of the given size with zeros. A synonym for link::Classes/ArrayedCollection#*newClear#*newClear::.

code::
Signal.zeroFill(1000).plot;
::

argument:: size
the number of samples in the Signal.


subsection:: Analytic & Hilbert


METHOD:: analyticFill

Return a complex analytic Signal of the given size with a sum of cosines and a sum of sines at the given amplitudes and phases. The Signal will be normalized.

code::
(
var complex;
complex = Signal.analyticFill(1000, 1.0/[1, 2, 3, 4, 5, 6]);
complex.real.plot("real");
complex.imag.plot("imag");
)
::

argument:: size
the number of samples in the Signal.

argument:: amplitudes
an Array of amplitudes for each harmonic beginning with the fundamental.

argument:: phases
an Array of phases in radians for each harmonic beginning with the fundamental.


METHOD:: hilbert

Hilbert Transform: Return complex Hilbert Transform coefficients.

code::
(
var complex;
complex = Signal.hilbert(2048);
complex.real.plot("real");
complex.imag.plot("imag");
)
::

argument:: size
the number of samples in the Signal.

argument:: pad
the number of samples of the size that is zero padding.

argument:: sym
a Boolean indicating whether the window is symmetric or periodic. Default is false.


INSTANCEMETHODS::

METHOD:: addCosine

Add a single cosine to myself with the given harmonic, amplitude and phase.


METHOD:: cosineFill

Add a sum of cosines to myself with the given amplitudes and phases.

code::
Signal.cosineFill(1000, 1.0/[1, 2, 3, 4, 5, 6]).plot;
::

argument:: amplitudes
an Array of amplitudes for each harmonic beginning with the fundamental.

argument:: phases
an Array of phases in radians for each harmonic beginning with the fundamental.


METHOD:: cosineFill2

Add a sum of cosines to myself with the given harmonics, amplitudes and phases.

code::
(
var numharms, harms, amps, phases, list;

numharms = 6;
harms = Array.rand(numharms, 1, 16);
amps = Array.rand(numharms, 0, -12).dbamp;
phases = Array.rand(numharms, 0, 2pi);

list = [harms, amps, phases].lace.clump(3);
Signal.newClear(1000).cosineFill2(list).plot;
)
::

argument:: list
a rank 2 collection containing harmonic numbers, amplitudes and phases.


METHOD:: wrapExtend

Returns a new Signal whose elements are repeated sequences of the receiver, up to size length. The receiver is unchanged.

code::
(
var numharms, harms, amps, phases, list;
var size = 600;
var real1, real2;

numharms = 6;
harms = Array.rand(numharms, 1, 16);
amps = Array.rand(numharms, 0, -12).dbamp;
phases = Array.rand(numharms, 0, 2pi);

list = [harms, amps, phases].lace.clump(3);
real1 = Signal.newClear(size).cosineFill2(list);
real2 = real1.wrapExtend(size.nextPowerOfTwo);

[real1.zeroPad(size.nextPowerOfTwo), real2 ].flop.flat
    .plot("wrapExtend", Rect(0, 0, 512 + 8, 500), numChannels: 2);

)
::

subsection:: Unary Messages

METHOD:: flip

The flip operator.

code::
(
var size = 1000;
var cosine, sine, cosineF, sineF;

cosine = Signal.newClear(size).cosineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125]]);
sine = Signal.newClear(size).sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125]]);

cosineF = cosine.flip;
sineF = sine.flip;

[cosine, cosineF, sine, sineF].flop.flat
    .plot("cosine, cosine.flip, sine, sine.flip", Rect(0, 0, size + 8, 500), numChannels: 4);
)
::


subsection:: Binary Messages

METHOD:: convolve

Convolve myself with a signal.

code::
(
var size1 = 1000, size2 = 200, size3;
var win1, win2, win3;

win1 = Signal.hannWindow(size1);
win2 = Signal.series(size2, 0.0, (size2.reciprocal));

win3 = win1.convolve(win2);

size3 = win3.size;


[win1.zeroPad(size3), win2.zeroPad(size3), win3.zeroPad(size3)].flop.flat
.plot("win1, win2, win1*win2", Rect(0, 0, size3 + 8, 500), numChannels: 3);
)
::

argument:: aSignal
the multiplier.

argument:: method

table::
    ## code::'fft':: || Radix-2 Discrete Fourier Transform
    ## code::'dft':: || Discrete Fourier Transform
    ## code::'dir':: || evaluate directly
::



subsection:: Analytic & Complex

METHOD:: analytic

Hilbert Transform: Return a complex analytic signal from a real signal.

code::
(
var numharms, harms, amps, phases, list;
var real, complex;

numharms = 6;
harms = Array.rand(numharms, 1, 16);
amps = Array.rand(numharms, 0, -12).dbamp;
phases = Array.rand(numharms, 0, 2pi);

list = [harms, amps, phases].lace.clump(3);
real = Signal.newClear(1000).cosineFill2(list);
complex = real.analytic;

[real, complex.real, complex.imag].flop.flat
    .plot("real, complex.real, complex.imag", Rect(0, 0, 1000 + 8, 500), numChannels: 3);
)
::


METHOD:: complex

Return a complex signal with the given real and imaginary parts.

code::
(
var size = 1000, real, imag, complex;

real = Signal.newClear(size).sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
imag = Signal.newClear(size).overDub(Signal.fill(size, { 0.2.bilinrand }));

complex = real.complex(imag);
[complex.real, complex.imag].flop.flat
    .plot("complex.real, complex.imag", Rect(0, 0, 1000 + 8, 500), numChannels: 2);
)
::


subsection:: Rotation & Phase

METHOD:: rotateWave

Rotate the Signal by a value in radians, strong::in place::.

NOTE::The signal is regarded as one period of a waveform.::

code::
(
var size = 1000, real, rotated;

real = Signal.newClear(size).cosineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);

rotated = real.deepCopy.rotateWave(-pi/2);

[real, rotated].flop.flat
    .plot("rotate waveform: original and rotated", Rect(0, 0, 1000 + 8, 500), numChannels: 2);
)
::


METHOD:: rotatePhase

Rotate the phase of Signal by a value in radians, strong::in place::.

code::
(
var size = 1000, real, rotated;

real = Signal.newClear(size).cosineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);

rotated = real.deepCopy.rotatePhase(-pi/2);

[real, rotated].flop.flat
    .plot("rotate phase: original and rotated", Rect(0, 0, 1000 + 8, 500), numChannels: 2);
)
::


METHOD:: linearPhase

Return a linear phase kernel, preserving the magnitude, strong::in place::.

code::
(
var numharms, harms, amps, phases, list;
var real, reset;

numharms = 16;
harms = Array.rand(numharms, 1, 16);
amps = Array.rand(numharms, 0, -12).dbamp;
phases = Array.rand(numharms, 0, 2pi);

list = [harms, amps, phases].lace.clump(3);
real = Signal.newClear(1000).cosineFill2(list).normalize;
real = real * Signal.hannWindow(1000);  // window

reset = real.deepCopy.linearPhase;

[real, reset].flop.flat
    .plot("reset phase: original and linear", Rect(0, 0, 1000 + 8, 500), numChannels: 2);
)
::

argument:: sym
a Boolean indicating whether the window is symmetric or periodic. Default is false.


METHOD:: minimumPhase

Return a minimum phase kernel, preserving the magnitude, strong::in place::.

code::
(
var numharms, harms, amps, phases, list;
var real, reset;

numharms = 16;
harms = Array.rand(numharms, 1, 16);
amps = Array.rand(numharms, 0, -12).dbamp;
phases = Array.rand(numharms, 0, 2pi);

list = [harms, amps, phases].lace.clump(3);
real = Signal.newClear(1000).cosineFill2(list).normalize;
real = real * Signal.hannWindow(1000);  // window

reset = real.deepCopy.minimumPhase(oversample: 8);

[real, reset].flop.flat
    .plot("reset phase: original and minimum", Rect(0, 0, 1000 + 8, 500), numChannels: 2);
)
::

argument:: mindb
a minimum value in dB to clip amplitude response to. Reduces time aliasing.

argument:: oversample
time oversampling scale factor. May be a float or an integer. Reduces time aliasing.


METHOD:: even

Return the even part of a signal.

code::
(
var size = 1000, numharms = 16, harms, amps, phases, list;
var cosines, sines, sum, even, odd;

harms = Array.rand(numharms, 1, numharms);
amps = Array.rand(numharms, 0, -12).dbamp;
phases = Array.zeroFill(numharms);

list = [harms, amps, phases].lace.clump(3);

cosines = Signal.newClear(1000).cosineFill2(list.keep((numharms/2).asInteger)).normalize;  // half as cosines...
sines = Signal.newClear(1000).sineFill2(list.keep((numharms.neg/2).asInteger)).normalize;  // ... half as sines

sum = cosines + sines;  // sum

even = sum.even;  // even is cosines!
odd = sum.odd;  // odd is sines!

[cosines, sines, sum, even, odd].flop.flat
.plot("cosines, sines, sum, even, odd", Rect(0, 0, 1000 + 8, 500), numChannels: 5);
)
::



METHOD:: odd

Return the odd part of a signal.


subsection:: RMS & Magnitude

METHOD:: rms

Return the RMS of a signal.

code::
Signal.rectWindow(1000).rms;
Signal.sineFill(1000, [1]).rms;
Signal.cosineFill(1000, [1]).rms;
Signal.hannWindow(1000).rms;
::

METHOD:: peakMagnitude

Return the peak of the frequency domain magnitude of a signal.

code::
(
var size = 512, real, imag, cosTable, complex;
var peakMag;

real = Signal.newClear(size);
        // some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
        // add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

peakMag = (real.peakMagnitude / 100);  // scale to plotted value


imag = Signal.newClear(size);
cosTable = Signal.fftCosTable(size);

complex = fft(real, imag, cosTable);

[real, imag, (complex.magnitude) / 100 ].flop.flat
    .plot("fft: peak magnitude = %".format(peakMag), Rect(0, 0, 512 + 8, 500), numChannels: 3);
)
::

argument:: oversample
time oversampling scale factor. May be a float or an integer.


METHOD:: normalizeMagnitude

Normalize the Signal strong::in place:: such that the maximum magnitude in the frequency domain is 1.

code::
(
var size = 512, real, imag, cosTable, complex;

real = Signal.newClear(size);
        // some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
        // add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

// real.put(0, -12.dbamp);  // for comparison... impulse response
real.normalizeMagnitude;

imag = Signal.newClear(size);
cosTable = Signal.fftCosTable(size);

complex = fft(real, imag, cosTable);

[real, imag, (complex.magnitude) ].flop.flat
    .plot("fft: peak magnitude = 1.0", Rect(0, 0, 512 + 8, 500), numChannels: 3);
)
::

argument:: oversample
time oversampling scale factor. May be a float or an integer.



subsection:: Cepstrum

METHOD:: rceps

Return the real part of the cepstrum of a real signal.

code::
(
var size = 1000, real, realceps;

real = Signal.newClear(size);
        // some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
        // add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

        // make an "echo"
real.overDub(real.rotateWave(-pi/4));

realceps = rceps(real);
[real, realceps].flop.flat
    .plot("rceps", Rect(0, 0, 1000 + 8, 500), numChannels: 2);
)
::


METHOD:: irceps

Return the real part of the inverse of the real part of the cepstrum.

code::
(
var size = 1000, real, realceps, irealceps;

real = Signal.newClear(size);
        // some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);

        // add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));


realceps = rceps(real);
irealceps = irceps(realceps);

[real, irealceps].flop.flat
    .plot("irceps - phase is lost!", Rect(0, 0, 1000 + 8, 500), numChannels: 2);
)
::


subsection:: Chirp z-Transform

METHOD:: czt

Perform a Chirp z-Transform on a real and imaginary signal.

code::
(
var size = 1000, real, imag, complex;

real = Signal.newClear(size);
        // some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
        // add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

imag = Signal.newClear(size);

complex = czt(real, imag);  // just the DFT!
[real, (complex.magnitude) / 100 ].flop.flat
    .plot("dft via czt", Rect(0, 0, 1000 + 8, 500), numChannels: 2);
)
::

argument:: imag
imaginary signal.

argument:: cwtsize
the number of coefficients to return. Defaults to code::this.size::.

argument:: step
ratio between points along the z-plane spiral contour of interest. Defaults to code::(0.0.complex(-2pi/cwtsize)).exp::.

argument:: start
complex starting point on that contour. Defaults to code::1::.

NOTE::The default code::nil:: values of code::cwtsize::, code::step::, and code::start:: return the DFT.::


METHOD:: rczt

Perform a Chirp z-Transform on a real signal.

code::
(
var size = 1000, real, complex;

real = Signal.newClear(size);
        // some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
        // add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

complex = rczt(real);  // just the DFT!
[real, (complex.magnitude) / 100 ].flop.flat
    .plot("dft via rczt", Rect(0, 0, 1000 + 8, 500), numChannels: 2);
)
::

argument:: cwtsize
the number of coefficients to return. Defaults to code::this.size::.

argument:: step
ratio between points along the z-plane spiral contour of interest. Defaults to code::(0.0.complex(-2pi/cwtsize)).exp::.

argument:: start
complex starting point on that contour. Defaults to code::1::.

NOTE::The default code::nil:: values of code::cwtsize::, code::step::, and code::start:: return the DFT.::


subsection:: Fourier Transform

METHOD:: fftToRfft

Return a complex Real-FFT spectrum from a complex FFT spectrum. See also the instance method link::#-rfftToFft::.

code::
(
var size = 512, rfftsize, real, imag, cosTable, complexFft, complexRfft;
rfftsize = size/2 + 1;

real = Signal.newClear(size);
        // some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
        // add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

imag = Signal.newClear(size);
cosTable = Signal.fftCosTable(size);

complexFft = fft(real, imag, cosTable);
complexRfft = complexFft.real.fftToRfft(complexFft.imag);
[real, imag, (complexFft.magnitude) / 100, (complexRfft.magnitude  ++ Signal.zeroFill(size - rfftsize)) / 100 ].flop.flat
    .plot("fft & rfft", Rect(0, 0, 512 + 8, 500), numChannels: 4);
)
::


METHOD:: rfft

Perform a Real-FFT on a real signal. See also the class method link::#*rfftCosTable::.

code::
(
var size = 512, rfftsize, real, cosTable, complex;

real = Signal.newClear(size);
        // some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
        // add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

rfftsize = size/2 + 1;
cosTable = Signal.rfftCosTable(rfftsize);

complex = rfft(real, cosTable);
[real, (complex.magnitude ++ Signal.zeroFill(size - rfftsize)) / 100 ].flop.flat
    .plot("rfft", Rect(0, 0, 512 + 8, 500), numChannels: 2);
)
::


METHOD:: irfft

Perform an inverse Real-FFT on a real and imaginary signal. See also the class method link::#*rfftCosTable::.

code::
(
var size = 512, rfftsize, real, cosTable, complex, irfft;

real = Signal.newClear(size);
        // some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
        // add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

rfftsize = size/2 + 1;
cosTable = Signal.rfftCosTable(rfftsize);

complex = rfft(real, cosTable).postln;
irfft = complex.real.irfft(complex.imag, cosTable);

[real, irfft].flop.flat
    .plot("rfft and back", Rect(0, 0, 512 + 8, 500), numChannels: 2);
)
::


METHOD:: rfftToFft

Return a complex FFT spectrum from a complex Real-FFT spectrum. See also the instance method link::#-fftToRfft::.

code::
(
var size = 512, rfftsize, real, cosTable, complexRfft, complexFft;

real = Signal.newClear(size);
        // some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
        // add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

rfftsize = size/2 + 1;
cosTable = Signal.rfftCosTable(rfftsize);

complexRfft = rfft(real, cosTable);
complexFft = complexRfft.real.rfftToFft(complexRfft.imag);
[real, (complexRfft.magnitude ++ Signal.zeroFill(size - rfftsize)) / 100, (complexFft.magnitude) / 100 ].flop.flat
    .plot("rfft & fft", Rect(0, 0, 512 + 8, 500), numChannels: 3);
)
::


METHOD:: rfftTwo

Perform a Real-FFT on two real signals. See also the class method link::#*rfftTwoCosTable::.

code::
(
var size = 512, rfftsize, real1, real2, cosTable, complexDict;

        // some harmonics
real1 = Signal.newClear(size);
real1.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);

        // some noise
real2 = Signal.newClear(size);
real2.overDub(Signal.fill(size, { 0.2.bilinrand }));

rfftsize = size/2 + 1;
cosTable = Signal.rfftTwoCosTable(rfftsize);

complexDict = rfftTwo(real1, real2, cosTable);
[real1, (complexDict[\rfft1].magnitude ++ Signal.zeroFill(size - rfftsize)) / 100,
	real2, (complexDict[\rfft2].magnitude ++ Signal.zeroFill(size - rfftsize)) / 100
].flop.flat
    .plot("rfftTwo", Rect(0, 0, 512 + 8, 500), numChannels: 4);
)
::


METHOD:: irfftTwo

Perform an inverse Real-FFT on two real and imaginary signals. See also the class method link::#*rfftTwoCosTable::.

code::
(
var size = 512, rfftsize, real1, real2, cosTable, complexDict, irfftDict;

        // some harmonics
real1 = Signal.newClear(size);
real1.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);

        // some noise
real2 = Signal.newClear(size);
real2.overDub(Signal.fill(size, { 0.2.bilinrand }));

rfftsize = size/2 + 1;
cosTable = Signal.rfftTwoCosTable(rfftsize);

complexDict = rfftTwo(real1, real2, cosTable).postln;
irfftDict = complexDict[\rfft1].real.irfftTwo(complexDict[\rfft1].imag, complexDict[\rfft2].real, complexDict[\rfft2].imag, cosTable);

[real1, real2, irfftDict[\irfft1], irfftDict[\irfft2]].flop.flat
    .plot("rfftTwo and back", Rect(0, 0, 512 + 8, 500), numChannels: 4);
)
::


METHOD:: dft

Perform a DFT on a real and imaginary signal.

NOTE::code::size:: is not restricted to a power of two.::

code::
(
var size = 1000, real, imag, complex;

real = Signal.newClear(size);
        // some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
        // add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

imag = Signal.newClear(size);

complex = dft(real, imag);
[real, (complex.magnitude) / 100 ].flop.flat
    .plot("dft", Rect(0, 0, 1000 + 8, 500), numChannels: 2);
)
::

argument:: imag
imaginary signal.

argument:: method

table::
    ## code::'czt':: || Chirp z-Transform
    ## code::'dir':: || evaluate directly
::


METHOD:: idft

Perform an inverse DFT on a real and imaginary signal.

NOTE::code::size:: is not restricted to a power of two.::

code::
(
var size = 1000, real, imag, complex, idft;

real = Signal.newClear(size);
        // some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
        // add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

imag = Signal.newClear(size);

complex = dft(real, imag).postln;
idft = complex.real.idft(complex.imag);

[real, idft.real].flop.flat
    .plot("dft and back", Rect(0, 0, 1000 + 8, 500), numChannels: 2);
)
::

argument:: imag
imaginary signal.

argument:: method

table::
    ## code::'czt':: || Chirp z-Transform
    ## code::'dir':: || evaluate directly
::


METHOD:: dftZoom

Perform a Zoom DFT on a real and imaginary signal.

code::
(
var size = 512, zoomsize = 512, k0, k1, real, imag, complex;

k0 = 0;  // start at DC
k1 = 60;  // just above last harmonic

real = Signal.newClear(size);
        // some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
        // add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

imag = Signal.newClear(size);

complex = dftZoom(real, imag, zoomsize, k0, k1);
[real, (complex.magnitude) / 100 ].flop.flat
    .plot("dftZoom", Rect(0, 0, 512 + 8, 500), numChannels: 2);
)
::

NOTE::code::Signal.size:: is not restricted to a power of two.::

argument:: imag
imaginary signal.

argument:: zoomsize
the number of coefficients to return.

argument:: k0
lowest DFT coefficient. Not required to be an integer.

argument:: k1
highest DFT coefficient. Not required to be an integer.



METHOD:: rdftZoom

Perform a Zoom DFT on a real signal.

NOTE::code::Signal.size:: is not restricted to a power of two.::

code::
(
var size = 512, zoomsize = 512, k0, k1, real, complex;

k0 = 0;  // start at DC
k1 = 60;  // just above last harmonic

real = Signal.newClear(size);
        // some harmonics
real.sineFill2([[8], [13, 0.5], [21, 0.25], [55, 0.125, 0.5pi]]);
        // add a little noise
real.overDub(Signal.fill(size, { 0.2.bilinrand }));

complex = rdftZoom(real, zoomsize, k0, k1);
[real, (complex.magnitude) / 100 ].flop.flat
    .plot("rdftZoom", Rect(0, 0, 512 + 8, 500), numChannels: 2);
)
::

argument:: zoomsize
the number of coefficients to return.

argument:: k0
lowest DFT coefficient. Not required to be an integer.

argument:: k1
highest DFT coefficient. Not required to be an integer.



METHOD:: goertzel

Return individual terms of a DFT on a real and imaginary signal.

NOTE::code::Signal.size:: is not restricted to a power of two.::

code::
(
var size = 1000, real, imag, complex;
var k = [8, 13, 21, 55];

real = Signal.newClear(size);
        // some harmonics
real.cosineFill2([[k[0]], [k[1], 0.5], [k[2], 0.25], [k[3], 0.125, 0.5pi]]);

imag = Signal.newClear(size);

complex = goertzel(real, imag, k);


"synthesized harmonics".postln;
"  magnitude: ".post;
(complex.magnitude / (size/2)).postln;
"  phase: ".post;
(complex.phase).postln;
)
::

argument:: imag
imaginary signal.

argument:: k
DFT coefficient(s) as a single value or an Array. Not required to be an integer.

argument:: method

table::
    ## code::'iir':: || Goertzel's algorithm
    ## code::'dir':: || evaluate directly
    ## code::'czt':: || Chirp z-Transform
::


METHOD:: rgoertzel

Return individual terms of a DFT on a real signal.

NOTE::code::Signal.size:: is not restricted to a power of two.::

code::
(
var size = 1000, real, imag, complex;
var k = [8, 13, 21, 55];

real = Signal.newClear(size);
        // some harmonics
real.cosineFill2([[k[0]], [k[1], 0.5], [k[2], 0.25], [k[3], 0.125, 0.5pi]]);

complex = rgoertzel(real, k);


"synthesized harmonics".postln;
"  magnitude: ".post;
(complex.magnitude / (size/2)).postln;
"  phase: ".post;
(complex.phase).postln;
)
::

argument:: k
DFT coefficient(s) as a single value or an Array. Not required to be an integer.

argument:: method

table::
    ## code::'iir':: || Goertzel's algorithm
    ## code::'dir':: || evaluate directly
    ## code::'czt':: || Chirp z-Transform
::
