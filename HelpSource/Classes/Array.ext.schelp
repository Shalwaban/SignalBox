CLASSMETHODS::


METHOD:: zeroFill

Create a new array with all slots filled with 0.0.

code::
Array.zeroFill(8)
::


subsection:: Fourier Transform

METHOD:: logShelf

Create a new Array whose slots are filled with linearly spaced magnitudes to create a log shelf filter.FOOTNOTE::Baird, J; Jackson, B; and D McGrath. “Raised Cosine Equalization Utilizing Log Scale Filter Synthesis.“ 117th Audio Engineering Society Convention, San Francisco, USA. October 2004. Permalink: link::http://www.aes.org/e-lib/browse.cfm?elib=12914::
:: See also: link::Classes/Signal#*logShelf::.


argument:: size
The size of the array to return.

argument:: freq0
The frequeny, at which to begin transition from strong::gainDC:: to strong::gainNy::, in Hz.

argument:: freq1
The frequeny, at which to end transition from strong::gainDC:: to strong::gainNy::, in Hz.

argument:: gainDC
The gain at DC, in dB.

argument:: gainNy
The gain at Nyquist, in dB.

argument:: sampleRate
The sample rate, in Hz.



INSTANCEMETHODS::

subsection:: Fourier Transform


METHOD:: linearPhase

Given an array of magnitudes returned by link::Classes/Signal#-fft::, answer the corresponding linear phase.
See also: link::Classes/Signal#-linearPhase::.

code::
(
var numharms = 16, harms, amps, phases, list;
var size = 512, real, imag, complex, phase, linPhase;

harms = Array.rand(numharms, 1, 16);
amps = Array.rand(numharms, 0, -12).dbamp;
phases = Array.rand(numharms, 0, 2pi);

list = [harms, amps, phases].lace.clump(3);
real = Signal.newClear(size).cosineFill2(list).normalize;
real = real * Signal.hannWindow(size);  // window
imag = Signal.newClear(size);

complex = dft(real, imag);

phase = complex.phase;  // original phase
linPhase = complex.magnitude.linearPhase;  // linear phase

[phase, linPhase ].flop.flat
    .plot("phase: original and linear", Rect(0, 0, size + 8, 500), numChannels: 2);
)
::

argument:: sym
a Boolean indicating whether the window is symmetric or periodic. Default is false.


METHOD:: minimumPhase

Given an array of magnitudes returned by link::Classes/Signal#-fft::, answer the corresponding minimum phase.
See also: link::Classes/Signal#-minimumPhase::.

code::
(
var numharms = 16, harms, amps, phases, list;
var size = 512, real, imag, complex, phase, minPhase;

harms = Array.rand(numharms, 1, 16);
amps = Array.rand(numharms, 0, -12).dbamp;
phases = Array.rand(numharms, 0, 2pi);

list = [harms, amps, phases].lace.clump(3);
real = Signal.newClear(size).cosineFill2(list).normalize;
real = real * Signal.hannWindow(size);  // window
imag = Signal.newClear(size);

complex = dft(real, imag);

phase = complex.phase;  // original phase
minPhase = complex.magnitude.minimumPhase;  // minimum phase

[phase, minPhase ].flop.flat
    .plot("phase: original and minimum", Rect(0, 0, size + 8, 500), numChannels: 2);
)
::

argument:: mindb
a minimum value in dB to clip amplitude response to. Reduces time aliasing.
